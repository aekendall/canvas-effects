// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Lifestream = (function(_super) {
    __extends(Lifestream, _super);

    Lifestream.prototype.streamCount = 1;

    Lifestream.prototype.origin = {
      x: 0,
      y: 0
    };

    Lifestream.prototype.intervalVariance = 0;

    Lifestream.prototype.originVariance = 100;

    Lifestream.prototype.targetVariance = 100;

    Lifestream.prototype.colorVariance = 40;

    Lifestream.prototype.drawGizmos = false;

    Lifestream.prototype.velocity = 150;

    Lifestream.prototype.interval = 1000;

    Lifestream.prototype.tension = 0.35;

    Lifestream.prototype.maxSegments = 5;

    Lifestream.prototype.headFadeLength = 0.5;

    Lifestream.prototype.tailFadeLength = 0.5;

    Lifestream.prototype.opacity = 0.5;

    Lifestream.prototype.strokeWidth = 2;

    Lifestream.prototype.stroke = '#000000';

    function Lifestream(config) {
      Kinetic.Group.call(this, config);
      this.setup(config);
    }

    Lifestream.prototype.setup = function(config) {
      var color, i, setting, stream, value, _i, _ref, _results;
      for (setting in config) {
        if (!__hasProp.call(config, setting)) continue;
        value = config[setting];
        this[setting] = value;
      }
      this.streamArray = [];
      _results = [];
      for (i = _i = 0, _ref = this.streamCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        color = chroma(this.stroke).darken(Math.random() * this.colorVariance - 0.5 * this.colorVariance);
        stream = new Stream({
          interval: this.interval + (Math.random() * this.intervalVariance - 0.5 * this.intervalVariance),
          maxSegments: this.maxSegments,
          drawGizmos: this.drawGizmos,
          velocity: this.velocity,
          strokeWidth: this.strokeWidth,
          headFadeLength: this.headFadeLength,
          tailFadeLength: this.tailFadeLength,
          stroke: color.hex(),
          origin: {
            x: this.origin.x + Math.random() * this.originVariance - 0.5 * this.originVariance,
            y: this.origin.y + Math.random() * this.originVariance - 0.5 * this.originVariance
          }
        });
        this.streamArray.push(stream);
        _results.push(this.add(stream));
      }
      return _results;
    };

    Lifestream.prototype.start = function() {
      var layer,
        _this = this;
      if (!this.anim) {
        layer = this.getLayer();
        this.anim = new Kinetic.Animation(function(frame) {
          var adjusted, pos, stage, stream, _i, _len, _ref, _results;
          stage = _this.getStage();
          pos = stage.getPointerPosition();
          if (pos == null) {
            return;
          }
          adjusted = new Coord2d();
          _ref = _this.streamArray;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stream = _ref[_i];
            adjusted.fromObject(pos);
            adjusted.x += Math.random() * _this.targetVariance - 0.5 * _this.targetVariance;
            adjusted.y += Math.random() * _this.targetVariance - 0.5 * _this.targetVariance;
            _results.push(stream.update(frame.timeDiff, adjusted));
          }
          return _results;
        }, layer);
      }
      return this.anim.start();
    };

    return Lifestream;

  })(Kinetic.Group);

}).call(this);

/*
//@ sourceMappingURL=lifestream.map
*/
